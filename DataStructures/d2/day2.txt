Day 2:
--------

---> Yesterday
===============

In any problem solving 
3 statements are very important.
------> Sequential
------> conditional branching
------> looping/iterative constructs (aka goto statements)

We use functions as a means to organize our code by dividing the task/program into sub tasks/programs.

Let us understand the usages of these functions
----> Different syntaxes can be used in function
	----> functions taking no arguments returning nothing
	----> functions taking no arguments returning something
	----> functions taking arguments returning something

----> We will try to understand the working of functions (flow of control)
	----> Always remember your program starts with main() and ends with main()...
	----> see fun.c for learning about control flow in functions.
	----> see recur.c for learning about recursion and its similarities with iterative loops
	----> recursion is preferred when you need to write code in minimum lines of code and dont mind extra memory usage
	----> Using recursion:
		1. Factorial of a number
		2. Power of number raise to number.
		3. Fibonacci number.
		4. Reversing anarray.
		5. Tower of hanoi.
	----> What is Direct vs Indirect recursion?
		1. Direct = funA() -> funA()
		2. Indirect recursion = funA() -> funB() -> funA()
	----> Indirect recursion is also a way to achieve recursion.

	----> Consider an example where you remove the terminating if condition in recur.c
	----> eventually you will get a stack overflow which is segmentation fault.
	----> use option -S to generate assembly file of a C program.
	----> Tail recursion can be optimized by C compiler.
	----> use option like -o2 to set the level of optimization.
	----> gcc -S -o2 recur.c
	----> in tail recursion there is no recursive function call and stack space is not used due to optimization
	----> therefore there is no stack overflow or segmentation fault problems in optimized tail recursive code.



